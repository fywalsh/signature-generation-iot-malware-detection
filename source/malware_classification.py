#!/usr/bin/env python

"""
Performs Malware Classification using a Decision-Tree Classifier
"""

# Generic/Built-in
import argparse
from pathlib import Path

# Libs
import numpy as np
import pandas as pd
import pydotplus
from IPython.display import Image
from matplotlib import pyplot as plt
from six import StringIO
from sklearn.metrics import classification_report, plot_confusion_matrix
from sklearn.tree import DecisionTreeClassifier, _tree
from sklearn.model_selection import train_test_split
from sklearn.tree import export_graphviz

__author__ = "Fiona Walsh"
__credits__ = ["Piotr Płoński - get_rules function"]
__version__ = "1.0.0"
__status__ = "Dev"


def perform_classification(arguments, dataset):
    """
    Performs binary classification (malware or benign)

    Args:
        arguments: Test size (default is 30% used for test), Decision Tree depth (Maximum value)
        dataset: .DAT files containing Malware or Benign Syscalls to perform classification on

    Returns:
        None
    """
    # Load dataset
    train_test_dataset = pd.read_csv(dataset)

    # Divided the dataset in features and target variable
    feature_cols = train_test_dataset.columns[:train_test_dataset.columns.size - 1]
    x = train_test_dataset[feature_cols]  # Features
    y = train_test_dataset.label  # Target variable

    # Split dataset into training set and test set
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=arguments.test_size, random_state=1, stratify=y)

    # Create Decision Tree classifier object
    if arguments.tree_depth > 0:
        dt_clf = DecisionTreeClassifier(max_depth=arguments.tree_depth)
    else:
        dt_clf = DecisionTreeClassifier()

    # Train Decision Tree Classifier
    dt_clf = dt_clf.fit(x_train, y_train)

    # Predict the response for test dataset
    y_pred = dt_clf.predict(x_test)

    # Model Results
    print('################### - RESULTS - ###################')
    print('\nClassification Report:\n')
    print(classification_report(y_test, y_pred, digits=4, zero_division=0))
    print('###################################################\n')
    fig, ax = plt.subplots(figsize=(10, 6))
    plot_confusion_matrix(dt_clf, x_test, y_test, cmap="PuRd", ax=ax)
    plt.savefig(arguments.output + dataset.stem + "_confusion_matrix.png")
    print("Saved Confusion Matrix to {}".format(arguments.output + dataset.stem + "_confusion_matrix.png"))

    # Visualizing Decision Trees
    dot_data = StringIO()
    export_graphviz(dt_clf, out_file=dot_data, filled=True, rounded=True, special_characters=True,
                    feature_names=feature_cols, class_names=dt_clf.classes_)
    graph = pydotplus.graph_from_dot_data(dot_data.getvalue())
    graph.write_png(arguments.output + dataset.stem + "_decision_tree.png")
    Image(graph.create_png())

    print("Saved Decision Tree Image to {}".format(arguments.output + dataset.stem + "_decision_tree.png"))

    # Export rules
    rules = get_rules(dt_clf, list(x_train.columns), dt_clf.classes_)
    with open(arguments.output + dataset.stem + "_decision_tree_rules.txt", 'w') as file:
        for r in rules:
            file.write(r + "\n")
    print("Saved Decision Tree Rules to {}".format(arguments.output + dataset.stem + "_decision_tree_rules.txt"))


def get_rules(tree, feature_names, class_names):
    """
    Gets "if then else" rules from Decision Trees

    Args:
        tree: Decision Tree
        feature_names: Features (Syscall N-Grams)
        class_names: Benign or Malware

    Returns:
        rules: List containing the "if then else" rules from Decision Trees
    """
    tree_ = tree.tree_
    feature_name = [
        feature_names[i] if i != _tree.TREE_UNDEFINED else "undefined!"
        for i in tree_.feature
    ]

    paths = []
    path = []

    def recurse(node, path, paths):

        if tree_.feature[node] != _tree.TREE_UNDEFINED:
            name = feature_name[node]
            threshold = tree_.threshold[node]
            p1, p2 = list(path), list(path)
            p1 += [f"({name} <= {np.round(threshold, 3)})"]
            recurse(tree_.children_left[node], p1, paths)
            p2 += [f"({name} > {np.round(threshold, 3)})"]
            recurse(tree_.children_right[node], p2, paths)
        else:
            path += [(tree_.value[node], tree_.n_node_samples[node])]
            paths += [path]

    recurse(0, path, paths)

    # sort by samples count
    samples_count = [p[-1][1] for p in paths]
    ii = list(np.argsort(samples_count))
    paths = [paths[i] for i in reversed(ii)]

    rules = []
    for path in paths:
        rule = "if "

        for p in path[:-1]:
            if rule != "if ":
                rule += " and "
            rule += str(p)
        rule += " then "
        if class_names is None:
            rule += "response: " + str(np.round(path[-1][0][0][0], 3))
        else:
            classes = path[-1][0][0]
            l = np.argmax(classes)
            rule += f"class: {class_names[l]}"
        rules += [rule]

    return rules


if __name__ == '__main__':
    print('Running Script: {}'.format(__file__))

    parser = argparse.ArgumentParser(prog=__file__,
                                     usage='%(prog)s [options]',
                                     description='Performs malware classification')

    parser.add_argument("-i", "--input", help="Input directory")
    parser.add_argument("-o", "--output", help="Output directory")
    parser.add_argument("-t", "--test_size", help="Test split i.e. 0.3 (30% of dataset should be used for test)",
                        default=0.3, type=float)
    parser.add_argument("-d", "--tree_depth", help="Max tree depth i.e. 2", default=0, type=int)

    args = parser.parse_args()

    print('Arguments:\t{}\n\n'.format('\n\t\t'.join(f'{k}={v}' for k, v in vars(args).items())))

    dataset_files = Path(args.input).glob("*.csv")
    latest_dataset = max(dataset_files, key=lambda f: f.stat().st_mtime)

    print("Processing file: {}\n".format(latest_dataset))

    perform_classification(args, latest_dataset)
